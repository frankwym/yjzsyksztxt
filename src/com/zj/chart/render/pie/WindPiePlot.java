package com.zj.chart.render.pie;

import java.awt.AlphaComposite;
import java.awt.Color;
import java.awt.Composite;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Paint;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.geom.Arc2D;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.io.Serializable;
import java.util.Iterator;
import java.util.List;

import org.jfree.chart.entity.CategoryItemEntity;
import org.jfree.chart.entity.EntityCollection;
import org.jfree.chart.labels.CategoryToolTipGenerator;
import org.jfree.chart.labels.PieSectionLabelGenerator;
import org.jfree.chart.plot.PiePlotState;
import org.jfree.chart.plot.Plot;
import org.jfree.chart.plot.PlotRenderingInfo;
import org.jfree.chart.plot.PlotState;
import org.jfree.chart.urls.CategoryURLGenerator;
import org.jfree.chart.urls.PieURLGenerator;
import org.jfree.data.category.CategoryDataset;
import org.jfree.data.general.DatasetUtilities;
import org.jfree.data.general.DefaultPieDataset;
import org.jfree.data.general.PieDataset;
import org.jfree.text.TextUtilities;
import org.jfree.ui.RectangleInsets;
import org.jfree.ui.TextAnchor;
import org.jfree.util.ObjectList;
import org.jfree.util.ObjectUtilities;
import org.jfree.util.PublicCloneable;
import org.jfree.util.Rotation;
import org.jfree.util.ShapeUtilities;
import org.jfree.util.SortOrder;
import org.jfree.util.UnitType;



/**
 * A plot that displays data in the form of a pie chart, using data from any
 * class that implements the {@link PieDataset} interface. The example shown
 * here is generated by the <code>PieChartDemo2.java</code> program included
 * in the JFreeChart Demo Collection: <br>
 * <br>
 * <img src="../../../../images/PiePlotSample.png" alt="PiePlotSample.png" />
 * <P>
 * Special notes:
 * <ol>
 * <li>the default starting point is 12 o'clock and the pie sections proceed in
 * a clockwise direction, but these settings can be changed;</li>
 * <li>negative values in the dataset are ignored;</li>
 * <li>there are utility methods for creating a {@link PieDataset} from a
 * {@link org.jfree.data.category.CategoryDataset};</li>
 * </ol>
 * 
 * @see Plot
 * @see PieDataset
 */
@SuppressWarnings("serial")
public class WindPiePlot extends TPiePlot implements Cloneable, Serializable {

	private CategoryDataset categoryDataset;

	private double totalPartAngle;
	private double itemOverAngle;
	private double startDataAngle;
	
    /** The tooltip generator. */
	private CategoryToolTipGenerator baseToolTipGenerator;

    /** The URL generator. */
    private CategoryURLGenerator baseUrlGenerator;

    
    /** The tooltip generator. */
	private CategoryToolTipGenerator toolTipGenerator;

    /** The URL generator. */
    private CategoryURLGenerator urlGenerator;
    
    /** A list of tool tip generators (one per series). */
    private ObjectList toolTipGeneratorList;
    
    private ObjectList itemURLGeneratorList;
	/**
	 * Creates a new plot. The dataset is initially set to <code>null</code>.
	 */
	public WindPiePlot() {
		this(null);
	}

	/**
	 * Creates a plot that will draw a pie chart for the specified dataset.
	 * 
	 * @param dataset
	 *            the dataset (<code>null</code> permitted).
	 */
	public WindPiePlot(CategoryDataset dataset) {
		super();
		this.categoryDataset = dataset;

		this.totalPartAngle = 360.0 / this.categoryDataset.getRowCount()/2;
		this.itemOverAngle = this.totalPartAngle/this.categoryDataset.getColumnCount();
		//this.itemOverAngle = this.totalPartAngle/5;
		this.startDataAngle = 0.0;
		
		this.toolTipGenerator = null;
        this.toolTipGeneratorList = new ObjectList();
        this.itemURLGeneratorList = new ObjectList();
	}

	/**
	 * Draws the plot on a Java 2D graphics device (such as the screen or a
	 * printer).
	 * 
	 * @param g2
	 *            the graphics device.
	 * @param area
	 *            the area within which the plot should be drawn.
	 * @param anchor
	 *            the anchor point (<code>null</code> permitted).
	 * @param parentState
	 *            the state from the parent plot, if there is one.
	 * @param info
	 *            collects info about the drawing (<code>null</code>
	 *            permitted).
	 */
	public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor,
			PlotState parentState, PlotRenderingInfo info) {

		// adjust for insets...
		RectangleInsets insets = getInsets();
		insets.trim(area);

		if (info != null) {
			info.setPlotArea(area);
			info.setDataArea(area);
		}

		drawBackground(g2, area);
		drawOutline(g2, area);

		Shape savedClip = g2.getClip();
		g2.clip(area);

		Composite originalComposite = g2.getComposite();
		g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,
				getForegroundAlpha()));

		if (!DatasetUtilities.isEmptyOrNull(this.categoryDataset)) {
			drawPie(g2, area, info);
		} else {
			drawNoDataMessage(g2, area);
		}

		g2.setClip(savedClip);
		g2.setComposite(originalComposite);

		drawOutline(g2, area);

	}

	/**
	 * Draws the pie.
	 * 
	 * @param g2
	 *            the graphics device.
	 * @param plotArea
	 *            the plot area.
	 * @param info
	 *            chart rendering info.
	 */
	@SuppressWarnings("unchecked")
	protected void drawPie(Graphics2D g2, Rectangle2D plotArea,
			PlotRenderingInfo info) {

		PiePlotState state = initialise(g2, plotArea, this, null, info);

		// adjust the plot area for interior spacing and labels...
		double labelReserve = 0.0;
		if (this.getLabelGenerator() != null && !this.simpleLabels) {
			labelReserve = this.getLabelGap() + this.getMaximumLabelWidth();
		}
		double gapHorizontal = plotArea.getWidth()
				* (this.getInteriorGap() + labelReserve) * 2.0;
		double gapVertical = plotArea.getHeight() * this.getInteriorGap() * 2.0;

		if (DEBUG_DRAW_INTERIOR) {
			double hGap = plotArea.getWidth() * this.getInteriorGap();
			double vGap = plotArea.getHeight() * this.getInteriorGap();

			double igx1 = plotArea.getX() + hGap;
			double igx2 = plotArea.getMaxX() - hGap;
			double igy1 = plotArea.getY() + vGap;
			double igy2 = plotArea.getMaxY() - vGap;
			//g2.setPaint(Color.gray);
			g2.draw(new Rectangle2D.Double(igx1, igy1, igx2 - igx1, igy2 - igy1));
		}

		double linkX = plotArea.getX() + gapHorizontal / 2;
		double linkY = plotArea.getY() + gapVertical / 2;
		double linkW = plotArea.getWidth() - gapHorizontal;
		double linkH = plotArea.getHeight() - gapVertical;

		// make the link area a square if the pie chart is to be circular...
		if (this.isCircular()) {
			double min = Math.min(linkW, linkH) / 2;
			linkX = (linkX + linkX + linkW) / 2 - min;
			linkY = (linkY + linkY + linkH) / 2 - min;
			linkW = 2 * min;
			linkH = 2 * min;
		}

		// the link area defines the dog leg points for the linking lines to
		// the labels
		Rectangle2D linkArea = new Rectangle2D.Double(linkX, linkY, linkW,
				linkH);
		state.setLinkArea(linkArea);

		if (DEBUG_DRAW_LINK_AREA) {
			g2.setPaint(Color.blue);
			g2.draw(linkArea);
			g2.setPaint(Color.yellow);
			g2.draw(new Ellipse2D.Double(linkArea.getX(), linkArea.getY(),
					linkArea.getWidth(), linkArea.getHeight()));
		}

		// the explode area defines the max circle/ellipse for the exploded
		// pie sections. it is defined by shrinking the linkArea by the
		// linkMargin factor.
		double lm = 0.0;
		if (!this.simpleLabels) {
			lm = this.getLabelLinkMargin();
		}
		double hh = linkArea.getWidth() * lm * 2.0;
		double vv = linkArea.getHeight() * lm * 2.0;
		Rectangle2D explodeArea = new Rectangle2D.Double(linkX + hh / 2.0,
				linkY + vv / 2.0, linkW - hh, linkH - vv);

		state.setExplodedPieArea(explodeArea);

		// the pie area defines the circle/ellipse for regular pie sections.
		// it is defined by shrinking the explodeArea by the explodeMargin
		// factor.
		double maximumExplodePercent = getMaximumExplodePercent();
		double percent = maximumExplodePercent / (1.0 + maximumExplodePercent);

		double h1 = explodeArea.getWidth() * percent;
		double v1 = explodeArea.getHeight() * percent;
		Rectangle2D pieArea = new Rectangle2D.Double(explodeArea.getX() + h1
				/ 2.0, explodeArea.getY() + v1 / 2.0, explodeArea.getWidth()
				- h1, explodeArea.getHeight() - v1);

		if (DEBUG_DRAW_PIE_AREA) {
			g2.setPaint(Color.green);
			g2.draw(pieArea);
		}
		state.setPieArea(pieArea);
		state.setPieCenterX(pieArea.getCenterX());
		state.setPieCenterY(pieArea.getCenterY());
		state.setPieWRadius(pieArea.getWidth() / 2.0);
		state.setPieHRadius(pieArea.getHeight() / 2.0);

		// plot the data (unless the dataset is null)...
		double maxValue = DatasetUtilities.findMaximumRangeValue(this.categoryDataset).doubleValue();

		double nowStartDataAngle = state.getLatestAngle();

		for (int col = 0; col < this.categoryDataset.getColumnCount(); col++) {
			PieDataset dataset = DatasetUtilities.createPieDatasetForColumn(this.categoryDataset, col);
			if ((dataset != null) && (dataset.getKeys().size() > 0)) {
				List keys = dataset.getKeys();
				double totalValue = DatasetUtilities.calculatePieDatasetTotal(dataset);

				Rectangle2D[] labelArea = new Rectangle2D[keys.size()];
				int passesRequired = state.getPassesRequired();

				for (int pass = 0; pass < passesRequired; pass++) {
					for (int row = 0; row < keys.size(); row++) {
						Number n = dataset.getValue(row);
						
						if (n != null) {
							double value = n.doubleValue();
							if (value > 0.0) {
								value = (value * pieArea.getHeight())/ maxValue / 2.0;
								Rectangle2D areaRectangle2D = new Rectangle2D.Double(
										state.getPieCenterX() - value, state.getPieCenterY()- value, value * 2.0,value * 2.0);
								state.setPieArea(areaRectangle2D);
								
								drawItem(g2, row, explodeArea, state, pass, col);
							}else {
								double angle1 = 0;
								if (this.getDirection() == Rotation.CLOCKWISE) {
									if ((col != 0) && (row == 0) && (pass == 0))
										angle1 = state.getLatestAngle() - this.itemOverAngle * col;
									else
										angle1 = state.getLatestAngle();
									state.setLatestAngle(angle1 + this.totalPartAngle * -2.0);
								} else if (this.getDirection() == Rotation.ANTICLOCKWISE) {
									if ((col != 0) && (row == 0) && (pass == 0))
										angle1 = state.getLatestAngle() + this.itemOverAngle * col;
									else
										angle1 = state.getLatestAngle();
									state.setLatestAngle(angle1 + this.totalPartAngle * 2.0);
								}
							}
							
							if (this.simpleLabels) {
								DefaultPieDataset newDataset = (DefaultPieDataset) DatasetUtilities.createPieDatasetForRow(this.categoryDataset, row);
								newDataset.sortByValues(SortOrder.ASCENDING);
								double maxYearValue = newDataset.getValue(newDataset.getItemCount()-1).doubleValue();
								
								double labelValue = (maxYearValue * plotArea.getHeight())/ maxValue / 2.0;
								Rectangle2D labelAreaRectangle2D = new Rectangle2D.Double(
								state.getPieCenterX() - labelValue, state.getPieCenterY()- labelValue, labelValue * 2.0,labelValue * 2.0);
						
								labelArea[row] = labelAreaRectangle2D;
							}
						}
					}
				}
				if (this.simpleLabels&& (col == this.categoryDataset.getColumnCount() - 1)) {
					drawSimpleLabels(g2, keys, totalValue, plotArea, labelArea,state, col);
				}
			} else {
				drawNoDataMessage(g2, plotArea);
			}
			state.setLatestAngle(nowStartDataAngle);
		}
	}

	/**
	 * Draws a single data item.
	 * 
	 * @param g2
	 *            the graphics device (<code>null</code> not permitted).
	 * @param section
	 *            the section index.
	 * @param dataArea
	 *            the data plot area.
	 * @param state
	 *            state information for one chart.
	 * @param currentPass
	 *            the current pass index.
	 */
	@SuppressWarnings({ "unchecked", "deprecation" })
	protected void drawItem(Graphics2D g2, int row, Rectangle2D dataArea,
			PiePlotState state, int currentPass, int column) {

		Number n = this.categoryDataset.getValue(row, column);
		if (n == null) {
			return;
		}

		int columns = this.categoryDataset.getColumnCount();
		double angle1 = 0.0;
		double angle2 = 0.0;

		if (this.getDirection() == Rotation.CLOCKWISE) {
			if ((column != 0) && (row == 0) && (currentPass == 0))
				angle1 = state.getLatestAngle() - this.itemOverAngle * column;
			else
				angle1 = state.getLatestAngle();
			angle2 = angle1
					- (this.totalPartAngle + (columns - 1) * this.itemOverAngle)
					/ 2;
		} else if (this.getDirection() == Rotation.ANTICLOCKWISE) {
			if ((column != 0) && (row == 0) && (currentPass == 0))
				angle1 = state.getLatestAngle() + this.itemOverAngle * column;
			else
				angle1 = state.getLatestAngle();
			angle2 = angle1
					+ (this.totalPartAngle + (columns - 1) * this.itemOverAngle)
					/ 2;
		}

		double angle = (angle2 - angle1);
		if (Math.abs(angle) > getMinimumArcAngleToDraw()) {
			double ep = 0.0;
			double mep = getMaximumExplodePercent();
			if (mep > 0.0) {
				ep = getExplodePercent(row) / mep;
			}
			Rectangle2D arcBounds = getArcBounds(state.getPieArea(), state
					.getExplodedPieArea(), angle1, angle, ep);
			Arc2D.Double arc = new Arc2D.Double(arcBounds, angle1, angle,
					Arc2D.PIE);

			if (currentPass == 0) {
				if (this.getShadowPaint() != null) {
					Shape shadowArc = ShapeUtilities.createTranslatedShape(arc,
							(float) this.getShadowXOffset(), (float) this
									.getShadowYOffset());
					g2.setPaint(this.getShadowPaint());
					g2.fill(shadowArc);
				}
			} else if (currentPass == 1) {
				Comparable key = getSectionKey(row);
				Paint paint = lookupSectionPaint(row + column
						* this.categoryDataset.getRowCount());
				g2.setPaint(paint);
				g2.fill(arc);

				Paint outlinePaint = lookupSectionOutlinePaint(key);
				Stroke outlineStroke = lookupSectionOutlineStroke(key);
				if (this.isSectionOutlinesVisible()) {
					g2.setPaint(outlinePaint);
					g2.setStroke(outlineStroke);
					g2.draw(arc);
				}

				// update the linking line target for later
				// add an entity for the pie section
				if (state.getInfo() != null) {
					EntityCollection entities = state.getEntityCollection();
					if (entities != null) {
						addItemEntity(entities, this.categoryDataset, row, column, arc);
					}
				}
			}
		}
		if (this.getDirection() == Rotation.CLOCKWISE)
		{
			state.setLatestAngle(angle1 + this.totalPartAngle * -2.0);
		}else {
			state.setLatestAngle(angle1 + this.totalPartAngle * 2.0);
		}
		
	}

	protected void addItemEntity(EntityCollection entities,
			CategoryDataset dataset, int row, int column, Shape hotspot) {

		String tip = null;
		CategoryToolTipGenerator tipster = getToolTipGenerator(row, column);
		if (tipster != null) {
			tip = tipster.generateToolTip(dataset, row, column);
		}
		String url = null;
		CategoryURLGenerator urlster = getItemURLGenerator(row, column);
		if (urlster != null) {
			url = urlster.generateURL(dataset, row, column);
		}
		CategoryItemEntity entity = new CategoryItemEntity(hotspot, tip, url,
				dataset, dataset.getRowKey(row), dataset.getColumnKey(column));
		entities.add(entity);

	}

	 public CategoryURLGenerator getItemURLGenerator(int row, int column) {
	        return getSeriesItemURLGenerator(row);
	    }

	    public CategoryURLGenerator getSeriesItemURLGenerator(int series) {

	        // return the generator for ALL series, if there is one...
	        if (this.urlGenerator!= null) {
	            return this.urlGenerator;
	        }

	        // otherwise look up the generator table
	        CategoryURLGenerator generator
	            = (CategoryURLGenerator) this.itemURLGeneratorList.get(series);
	        if (generator == null) {
	            generator = this.baseUrlGenerator;
	        }
	        return generator;

	    }
	    
	public CategoryToolTipGenerator getToolTipGenerator(int row, int column) {

        CategoryToolTipGenerator result = null;
        if (this.toolTipGenerator != null) {
            result = this.toolTipGenerator;
        }
        else {
            result = getSeriesToolTipGenerator(row);
            if (result == null) {
                result = this.baseToolTipGenerator;
            }
        }
        return result;
    }
	
	public CategoryToolTipGenerator getSeriesToolTipGenerator(int series) {
        return (CategoryToolTipGenerator) this.toolTipGeneratorList.get(series);
    }
	
	/**
	 * Draws the pie section labels in the simple form.
	 * 
	 * @param g2
	 *            the graphics device.
	 * @param keys
	 *            the section keys.
	 * @param totalValue
	 *            the total value for all sections in the pie.
	 * @param plotArea
	 *            the plot area.
	 * @param pieArea
	 *            the area containing the pie.
	 * @param state
	 *            the plot state.
	 * 
	 * @since 1.0.7
	 */
	@SuppressWarnings("unchecked")
	protected void drawSimpleLabels(Graphics2D g2, List keys,
			double totalValue, Rectangle2D plotArea, Rectangle2D[] pieArea,
			PiePlotState state, int column) {

		Composite originalComposite = g2.getComposite();
		g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,
				1.0f));

		RectangleInsets labelInsets = new RectangleInsets(UnitType.RELATIVE,
				0.18, 0.18, 0.18, 0.18);

		int row = 0;
		double runningTotal = 0.0;
		Iterator iterator = keys.iterator();
		while (iterator.hasNext()) {
			Comparable key = (Comparable) iterator.next();
			Rectangle2D labelsArea = labelInsets.createInsetRectangle(pieArea[row]);

			boolean include = true;
			double v = 0.0;
			Number n = this.categoryDataset.getValue(row, column);
			if (n == null) {
				include = !getIgnoreNullValues();
			} else {
				v = n.doubleValue();
				include = getIgnoreZeroValues() ? v > 0.0 : v >= 0.0;
			}

			if (include) {
				runningTotal = runningTotal + v;
				// work out the mid angle (0 - 90 and 270 - 360) = right,
				// otherwise left
				double mid = getStartAngle()
						+ (getDirection().getFactor()
								* ((runningTotal - v / 2.0) * 360) / totalValue);

				Arc2D arc = new Arc2D.Double(labelsArea, getStartAngle(), mid
						- getStartAngle(), Arc2D.OPEN);
				int x = (int) arc.getEndPoint().getX();
				int y = (int) arc.getEndPoint().getY();

				PieSectionLabelGenerator labelGenerator = getLabelGenerator();
				if (labelGenerator == null) {
					continue;
				}
				String label = labelGenerator.generateSectionLabel(
						DatasetUtilities.createPieDatasetForColumn(
								this.categoryDataset, column), key);
				if (label == null) {
					continue;
				}
				g2.setFont(this.getLabelFont());
				FontMetrics fm = g2.getFontMetrics();
				Rectangle2D bounds = TextUtilities.getTextBounds(label, g2, fm);
				Rectangle2D out = this.getLabelPadding().createOutsetRectangle(
						bounds);
				Shape bg = ShapeUtilities.createTranslatedShape(out, x
						- bounds.getCenterX(), y - bounds.getCenterY());
				if (this.getLabelShadowPaint() != null) {
					Shape shadow = ShapeUtilities.createTranslatedShape(bg,
							this.getShadowXOffset(), this.getShadowYOffset());
					g2.setPaint(this.getLabelShadowPaint());
					g2.fill(shadow);
				}
				if (this.getLabelBackgroundPaint() != null) {
					g2.setPaint(this.getLabelBackgroundPaint());
					g2.fill(bg);
				}
				if (this.getLabelOutlinePaint() != null
						&& this.getLabelOutlineStroke() != null) {
					g2.setPaint(this.getLabelOutlinePaint());
					g2.setStroke(this.getLabelOutlineStroke());
					g2.draw(bg);
				}

				g2.setPaint(this.getLabelPaint());
				g2.setFont(this.getLabelFont());
				TextUtilities.drawAlignedString(getLabelGenerator()
						.generateSectionLabel(
								DatasetUtilities.createPieDatasetForColumn(
										this.categoryDataset, column), key),
						g2, x, y, TextAnchor.CENTER);
			}
			row++;
		}

		g2.setComposite(originalComposite);

	}

	/**
	 * Returns a clone of the plot.
	 * 
	 * @return A clone.
	 * 
	 * @throws CloneNotSupportedException
	 *             if some component of the plot does not support cloning.
	 */
	public Object clone() throws CloneNotSupportedException {
		TPiePlot clone = (TPiePlot) super.clone();
		if (clone.dataset != null) {
			clone.dataset.addChangeListener(clone);
		}
		if (this.getUrlGenerator() instanceof PublicCloneable) {
			clone.setUrlGenerator((PieURLGenerator) ObjectUtilities.clone(this
					.getUrlGenerator()));
		}
		clone.setLegendItemShape(ShapeUtilities
				.clone(this.getLegendItemShape()));
		if (this.getLegendLabelGenerator() != null) {
			clone.setLegendLabelGenerator((PieSectionLabelGenerator) ObjectUtilities
							.clone(this.getLegendLabelGenerator()));
		}
		if (this.getLegendLabelToolTipGenerator() != null) {
			clone.setLegendLabelToolTipGenerator((PieSectionLabelGenerator) ObjectUtilities
							.clone(this.getLegendLabelToolTipGenerator()));
		}
		if (this.getLegendLabelURLGenerator() instanceof PublicCloneable) {
			clone.setLegendLabelURLGenerator((PieURLGenerator) ObjectUtilities.clone(this.getLegendLabelURLGenerator()));
		}
		return clone;
	}

	public double maxValue(CategoryDataset dataset) {

		double maxValue = dataset.getValue(0, 0).doubleValue();

		for (int col = 0; col < dataset.getColumnCount(); col++) {
			for (int row = 0; row < dataset.getRowCount(); row++) {
				Number n = dataset.getValue(row, col);
				if (n != null && (n.doubleValue() > maxValue)) {
					maxValue = n.doubleValue();
				}
			}
		}
		return maxValue;
	}

	@SuppressWarnings("deprecation")
	public void setSectionPaint(int row, int col, Paint paint) {
		this.setSectionPaint(row + this.categoryDataset.getRowCount() * col,
				paint);
	}

	@SuppressWarnings("unchecked")
	public void setSectionPaint(Comparable rowkey, Comparable colkey,
			Paint paint) {
		int rowIndex = this.categoryDataset.getRowIndex(rowkey);
		int colIndex = this.categoryDataset.getColumnIndex(colkey);

		this.setSectionPaint(rowIndex, colIndex, paint);
	}

	public CategoryDataset getCategoryDataset() {
		return categoryDataset;
	}

	public void setCategoryDataset(CategoryDataset categoryDataset) {
		this.categoryDataset = categoryDataset;
	}

	public CategoryToolTipGenerator getBaseToolTipGenerator() {
		return baseToolTipGenerator;
	}

	public void setBaseToolTipGenerator(
			CategoryToolTipGenerator baseToolTipGenerator) {
		this.baseToolTipGenerator = baseToolTipGenerator;
	}

	public CategoryURLGenerator getBaseUrlGenerator() {
		return baseUrlGenerator;
	}

	public void setBaseUrlGenerator(CategoryURLGenerator baseUrlGenerator) {
		this.baseUrlGenerator = baseUrlGenerator;
	}


	public void setToolTipGenerator(CategoryToolTipGenerator toolTipGenerator) {
		this.toolTipGenerator = toolTipGenerator;
	}


	public void setUrlGenerator(CategoryURLGenerator urlGenerator) {
		this.urlGenerator = urlGenerator;
	}

	public double getTotalPartAngle() {
		return totalPartAngle;
	}

	public void setTotalPartAngle(double totalPartAngle) {
		this.totalPartAngle = totalPartAngle;
	}

	public double getItemOverAngle() {
		return itemOverAngle;
	}

	public void setItemOverAngle(double itemOverAngle) {
		this.itemOverAngle = itemOverAngle;
	}

	public double getStartDataAngle() {
		return startDataAngle;
	}

	public void setStartDataAngle(double startDataAngle) {
		this.startDataAngle = startDataAngle;
	}
}
