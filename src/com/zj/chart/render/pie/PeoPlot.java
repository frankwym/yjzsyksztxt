package com.zj.chart.render.pie;

import java.awt.AlphaComposite;
import java.awt.Color;
import java.awt.Composite;
import java.awt.Graphics2D;
import java.awt.Paint;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.geom.Arc2D;
import java.awt.geom.Ellipse2D;
import java.awt.geom.GeneralPath;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.io.Serializable;
import java.util.List;


import org.jfree.chart.entity.EntityCollection;
import org.jfree.chart.entity.PieSectionEntity;
import org.jfree.chart.labels.PieSectionLabelGenerator;
import org.jfree.chart.labels.PieToolTipGenerator;
import org.jfree.chart.plot.PiePlotState;
import org.jfree.chart.plot.Plot;
import org.jfree.chart.plot.PlotRenderingInfo;
import org.jfree.chart.plot.PlotState;
import org.jfree.chart.urls.PieURLGenerator;
import org.jfree.data.general.DatasetUtilities;
import org.jfree.data.general.PieDataset;
import org.jfree.ui.RectangleInsets;
import org.jfree.util.ObjectUtilities;
import org.jfree.util.PublicCloneable;
import org.jfree.util.ShapeUtilities;

/**
 * A plot that displays data in the form of a pie chart, using data from any
 * class that implements the {@link PieDataset} interface.
 * The example shown here is generated by the <code>PieChartDemo2.java</code>
 * program included in the JFreeChart Demo Collection:
 * <br><br>
 * <img src="../../../../images/PiePlotSample.png"
 * alt="PiePlotSample.png" />
 * <P>
 * Special notes:
 * <ol>
 * <li>the default starting point is 12 o'clock and the pie sections proceed
 * in a clockwise direction, but these settings can be changed;</li>
 * <li>negative values in the dataset are ignored;</li>
 * <li>there are utility methods for creating a {@link PieDataset} from a
 * {@link org.jfree.data.category.CategoryDataset};</li>
 * </ol>
 *
 * @see Plot
 * @see PieDataset
 */
@SuppressWarnings("serial")
public class PeoPlot extends TPiePlot implements Cloneable, Serializable {
	private double totalAngle;
	@SuppressWarnings("unused")
	private boolean bMale = true;;
	/**
	 * Creates a new plot.  The dataset is initially set to <code>null</code>.
	 */
	public PeoPlot() {
		this(null);
	}

	/**
	 * Creates a plot that will draw a pie chart for the specified dataset.
	 *
	 * @param dataset  the dataset (<code>null</code> permitted).
	 */
	public PeoPlot(PieDataset dataset) {
		super();
		this.dataset = dataset;
		if (dataset != null) {
			dataset.addChangeListener(this);
		}

		totalAngle = 330;
	}

	/**
	 * Draws the plot on a Java 2D graphics device (such as the screen or a
	 * printer).
	 *
	 * @param g2  the graphics device.
	 * @param area  the area within which the plot should be drawn.
	 * @param anchor  the anchor point (<code>null</code> permitted).
	 * @param parentState  the state from the parent plot, if there is one.
	 * @param info  collects info about the drawing
	 *              (<code>null</code> permitted).
	 */
	public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo info) {

		// adjust for insets...
		RectangleInsets insets = getInsets();
		insets.trim(area);

		if (info != null) {
			info.setPlotArea(area);
			info.setDataArea(area);
		}

		drawBackground(g2, area);
		drawOutline(g2, area);

		Shape savedClip = g2.getClip();
		g2.clip(area);

		Composite originalComposite = g2.getComposite();
		g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, getForegroundAlpha()));

		if (!DatasetUtilities.isEmptyOrNull(this.dataset)) {
			drawPie(g2, area, info);
		}
		else {
			drawNoDataMessage(g2, area);
		}

		g2.setClip(savedClip);
		g2.setComposite(originalComposite);

		drawOutline(g2, area);

	}

	/**
	 * Draws the pie.
	 *
	 * @param g2  the graphics device.
	 * @param plotArea  the plot area.
	 * @param info  chart rendering info.
	 */
	@SuppressWarnings("unchecked")
	protected void drawPie(Graphics2D g2, Rectangle2D plotArea, PlotRenderingInfo info) {

		PiePlotState state = initialise(g2, plotArea, this, null, info);

		// adjust the plot area for interior spacing and labels...
		double labelReserve = 0.0;
		if (this.getLabelGenerator() != null && !this.simpleLabels) {
			labelReserve = this.getLabelGap() + this.getMaximumLabelWidth();
		}
		double gapHorizontal = plotArea.getWidth() * (this.getInteriorGap() + labelReserve) * 2.0;
		double gapVertical = plotArea.getHeight() * this.getInteriorGap() * 2.0;

		if (DEBUG_DRAW_INTERIOR) {
			double hGap = plotArea.getWidth() * this.getInteriorGap();
			double vGap = plotArea.getHeight() * this.getInteriorGap();

			double igx1 = plotArea.getX() + hGap;
			double igx2 = plotArea.getMaxX() - hGap;
			double igy1 = plotArea.getY() + vGap;
			double igy2 = plotArea.getMaxY() - vGap;
			g2.setPaint(Color.gray);
			g2.draw(new Rectangle2D.Double(igx1, igy1, igx2 - igx1, igy2 - igy1));
		}

		double linkX = plotArea.getX() + gapHorizontal / 2;
		double linkY = plotArea.getY() + gapVertical / 2;
		double linkW = plotArea.getWidth() - gapHorizontal;
		double linkH = plotArea.getHeight() - gapVertical;

		// make the link area a square if the pie chart is to be circular...
		if (this.isCircular()) {
			double min = Math.min(linkW, linkH) / 2;
			linkX = (linkX + linkX + linkW) / 2 - min;
			linkY = (linkY + linkY + linkH) / 2 - min;
			linkW = 2 * min;
			linkH = 2 * min;
		}

		// the link area defines the dog leg points for the linking lines to
		// the labels
		Rectangle2D linkArea = new Rectangle2D.Double(linkX, linkY, linkW, linkH);
		state.setLinkArea(linkArea);

		if (DEBUG_DRAW_LINK_AREA) {
			g2.setPaint(Color.blue);
			g2.draw(linkArea);
			g2.setPaint(Color.yellow);
			g2.draw(new Ellipse2D.Double(linkArea.getX(), linkArea.getY(), linkArea.getWidth(), linkArea.getHeight()));
		}

		// the explode area defines the max circle/ellipse for the exploded
		// pie sections.  it is defined by shrinking the linkArea by the
		// linkMargin factor.
		double lm = 0.0;
		if (!this.simpleLabels) {
			lm = this.getLabelLinkMargin();
		}
		double hh = linkArea.getWidth() * lm * 2.0;
		double vv = linkArea.getHeight() * lm * 2.0;
		Rectangle2D explodeArea = new Rectangle2D.Double(linkX + hh / 2.0, linkY + vv / 2.0, linkW - hh, linkH - vv);

		state.setExplodedPieArea(explodeArea);

		// the pie area defines the circle/ellipse for regular pie sections.
		// it is defined by shrinking the explodeArea by the explodeMargin
		// factor.
		double maximumExplodePercent = getMaximumExplodePercent();
		double percent = maximumExplodePercent / (1.0 + maximumExplodePercent);

		double h1 = explodeArea.getWidth() * percent;
		double v1 = explodeArea.getHeight() * percent;
		Rectangle2D pieArea = new Rectangle2D.Double(explodeArea.getX() + h1 / 2.0, explodeArea.getY() + v1 / 2.0,
				explodeArea.getWidth() - h1, explodeArea.getHeight() - v1);

		if (DEBUG_DRAW_PIE_AREA) {
			g2.setPaint(Color.green);
			g2.draw(pieArea);
		}
		state.setPieArea(pieArea);
		state.setPieCenterX(pieArea.getCenterX());
		state.setPieCenterY(pieArea.getCenterY());
		state.setPieWRadius(pieArea.getWidth() / 2.0);
		state.setPieHRadius(pieArea.getHeight() / 2.0);

		// plot the data (unless the dataset is null)...
		if ((this.dataset != null) && (this.dataset.getKeys().size() > 0)) {

			List keys = this.dataset.getKeys();
			double totalValue = DatasetUtilities.calculatePieDatasetTotal(this.dataset);

			int passesRequired = state.getPassesRequired();
			for (int pass = 0; pass < passesRequired; pass++) {
				for (int section = 0; section < keys.size(); section++) {
					double value = 0.0;
					Number n = this.dataset.getValue(section);
					if (n.doubleValue() > 0.0) {
						value = pieArea.getHeight();

						drawItem(g2, section, value, state, pass);
					}
				}
			}

			if (this.simpleLabels) {
				drawSimpleLabels(g2, keys, totalValue, plotArea, linkArea, state);
			}
			else {
				drawLabels(g2, keys, totalValue, plotArea, linkArea, state);
			}

		}
		else {
			drawNoDataMessage(g2, plotArea);
		}
	}

	/**
	 * Draws a single data item.
	 *
	 * @param g2  the graphics device (<code>null</code> not permitted).
	 * @param section  the section index.
	 * @param dataArea  the data plot area.
	 * @param state  state information for one chart.
	 * @param currentPass  the current pass index.
	 */
	@SuppressWarnings("unchecked")
	protected void drawItem(Graphics2D g2, int section, double value, PiePlotState state, int currentPass) {
		Comparable key = getSectionKey(section);

		double angle = this.getTotalHeadAngle();
		double startAngle = (360.0 - angle) / 2.0 - 90.0;

		Rectangle2D arcArea = new Rectangle2D.Double(state.getPieCenterX() - value / 10, state.getPieCenterY() - value
				/ 2, value / 5, value / 5);

		Rectangle2D arcBounds = getArcBounds(arcArea, arcArea, startAngle, angle, 0.0);
		Arc2D.Double arc = new Arc2D.Double(arcBounds, startAngle, angle, Arc2D.OPEN);

		GeneralPath path = new GeneralPath();
		path.moveTo((float) arc.getStartPoint().getX(), (float) arc.getStartPoint().getY());

		path.append(arc.getPathIterator(null), false);
		path.lineTo(arc.getEndPoint().getX() - 0.15 * value, arc.getEndPoint().getY());
		path.lineTo(arc.getEndPoint().getX() - 0.15 * value, arc.getEndPoint().getY() + 0.4 * value);
		path.lineTo(arc.getEndPoint().getX() - 0.08 * value, arc.getEndPoint().getY() + 0.4 * value);
		path.lineTo(arc.getEndPoint().getX() - 0.08 * value, arc.getEndPoint().getY() + 0.8 * value);
		path.lineTo(arc.getStartPoint().getX() + 0.08 * value, arc.getEndPoint().getY() + 0.8 * value);
		path.lineTo(arc.getStartPoint().getX() + 0.08 * value, arc.getEndPoint().getY() + 0.4 * value);
		path.lineTo(arc.getStartPoint().getX() + 0.15 * value, arc.getEndPoint().getY() + 0.4 * value);
		path.lineTo(arc.getStartPoint().getX() + 0.15 * value, arc.getEndPoint().getY());
		path.closePath();

		if (currentPass == 0) {
			Paint shadowPaint = getShadowPaint();
			double shadowXOffset = getShadowXOffset();
			double shadowYOffset = getShadowYOffset();
			if (shadowPaint != null) {
				Shape shadowArc = ShapeUtilities.createTranslatedShape(path, (float) shadowXOffset,
						(float) shadowYOffset);
				g2.setPaint(shadowPaint);
				g2.fill(shadowArc);
			}
		}
		else if (currentPass == 1) {
			Paint paint = lookupSectionPaint(key);
			g2.setPaint(paint);
			g2.fill(path);
			Paint outlinePaint = lookupSectionOutlinePaint(key);
			Stroke outlineStroke = lookupSectionOutlineStroke(key);
			if (outlinePaint != null && outlineStroke != null) {
				g2.setPaint(outlinePaint);
				g2.setStroke(outlineStroke);
				g2.draw(path);
			}
			
			 // add an entity for the pie section
            if (state.getInfo() != null) {
                EntityCollection entities = state.getEntityCollection();
                if (entities != null) {
                    String tip = null;
                    PieToolTipGenerator toolTipGenerator
                            = getToolTipGenerator();
                    if (toolTipGenerator != null) {
                        tip = toolTipGenerator.generateToolTip(dataset,
                                key);
                    }
                    String url = null;
                    PieURLGenerator urlGenerator = getURLGenerator();
                    if (urlGenerator != null) {
                        url = urlGenerator.generateURL(dataset, key,
                                getPieIndex());
                    }
                    PieSectionEntity entity = new PieSectionEntity(path,
                            dataset, getPieIndex(), section, key, tip,
                            url);
                    entities.add(entity);
                }
            }
		}
	}

	public void setTotalHeadAngle(double angle) {
		if ((angle % 360.0) > 270.0) {
			this.totalAngle = angle;
		}
	}

	private double getTotalHeadAngle() {
		return totalAngle;
	}

	/**
	 * Returns a clone of the plot.
	 *
	 * @return A clone.
	 *
	 * @throws CloneNotSupportedException if some component of the plot does
	 *         not support cloning.
	 */
	public Object clone() throws CloneNotSupportedException {
		PeoPlot clone = (PeoPlot) super.clone();
		if (clone.dataset != null) {
			clone.dataset.addChangeListener(clone);
		}
		if (this.getUrlGenerator() instanceof PublicCloneable) {
			clone.setUrlGenerator((PieURLGenerator) ObjectUtilities.clone(this.getUrlGenerator()));
		}
		clone.setLegendItemShape(ShapeUtilities.clone(this.getLegendItemShape()));
		if (this.getLegendLabelGenerator() != null) {
			clone.setLegendLabelGenerator((PieSectionLabelGenerator) ObjectUtilities.clone(this
					.getLegendLabelGenerator()));
		}
		if (this.getLegendLabelToolTipGenerator() != null) {
			clone.setLegendLabelToolTipGenerator((PieSectionLabelGenerator) ObjectUtilities.clone(this
					.getLegendLabelToolTipGenerator()));
		}
		if (this.getLegendLabelURLGenerator() instanceof PublicCloneable) {
			clone
					.setLegendLabelURLGenerator((PieURLGenerator) ObjectUtilities.clone(this
							.getLegendLabelURLGenerator()));
		}
		return clone;
	}
}
